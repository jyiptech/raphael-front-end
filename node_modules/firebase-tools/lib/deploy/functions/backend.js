"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkAvailability = exports.existingBackend = exports.toJob = exports.fromGCFv2Function = exports.toGCFv2Function = exports.fromGCFv1Function = exports.toGCFv1Function = exports.scheduleIdForFunction = exports.topicName = exports.scheduleName = exports.sameFunctionName = exports.functionName = exports.isEmptyBackend = exports.empty = exports.isValidRuntime = exports.memoryOptionDisplayName = exports.isEventTrigger = void 0;
const proto = require("../../gcp/proto");
const gcf = require("../../gcp/cloudfunctions");
const gcfV2 = require("../../gcp/cloudfunctionsv2");
const utils = require("../../utils");
const error_1 = require("../../error");
const logger_1 = require("../../logger");
const previews_1 = require("../../previews");
function isEventTrigger(trigger) {
    return "eventType" in trigger;
}
exports.isEventTrigger = isEventTrigger;
function memoryOptionDisplayName(option) {
    return {
        128: "128MB",
        256: "256MB",
        512: "512MB",
        1024: "1GB",
        2048: "2GB",
        4096: "4GB",
        8192: "8GB",
    }[option];
}
exports.memoryOptionDisplayName = memoryOptionDisplayName;
const RUNTIMES = ["nodejs10", "nodejs12", "nodejs14"];
function isValidRuntime(runtime) {
    return RUNTIMES.includes(runtime);
}
exports.isValidRuntime = isValidRuntime;
function empty() {
    return {
        requiredAPIs: {},
        cloudFunctions: [],
        schedules: [],
        topics: [],
    };
}
exports.empty = empty;
function isEmptyBackend(backend) {
    return (Object.keys(backend.requiredAPIs).length == 0 &&
        backend.cloudFunctions.length === 0 &&
        backend.schedules.length === 0 &&
        backend.topics.length === 0);
}
exports.isEmptyBackend = isEmptyBackend;
function functionName(cloudFunction) {
    return `projects/${cloudFunction.project}/locations/${cloudFunction.region}/functions/${cloudFunction.id}`;
}
exports.functionName = functionName;
exports.sameFunctionName = (func) => (test) => {
    return func.id === test.id && func.region === test.region && func.project == test.project;
};
function scheduleName(schedule, appEngineLocation) {
    return `projects/${schedule.project}/locations/${appEngineLocation}/jobs/${schedule.id}`;
}
exports.scheduleName = scheduleName;
function topicName(topic) {
    return `projects/${topic.project}/topics/${topic.id}`;
}
exports.topicName = topicName;
function scheduleIdForFunction(cloudFunction) {
    return `firebase-schedule-${cloudFunction.id}-${cloudFunction.region}`;
}
exports.scheduleIdForFunction = scheduleIdForFunction;
function toGCFv1Function(cloudFunction, sourceUploadUrl) {
    if (cloudFunction.apiVersion != 1) {
        throw new error_1.FirebaseError("Trying to create a v1 CloudFunction with v2 API. This should never happen");
    }
    if (!isValidRuntime(cloudFunction.runtime)) {
        throw new error_1.FirebaseError("Failed internal assertion. Trying to deploy a new function with a deprecated runtime." +
            " This should never happen");
    }
    const gcfFunction = {
        name: functionName(cloudFunction),
        sourceUploadUrl: sourceUploadUrl,
        entryPoint: cloudFunction.entryPoint,
        runtime: cloudFunction.runtime,
    };
    if (isEventTrigger(cloudFunction.trigger)) {
        gcfFunction.eventTrigger = {
            eventType: cloudFunction.trigger.eventType,
            resource: cloudFunction.trigger.eventFilters.resource,
        };
        gcfFunction.eventTrigger.failurePolicy = cloudFunction.trigger.retry
            ? { retry: {} }
            : undefined;
    }
    else {
        gcfFunction.httpsTrigger = {
            securityLevel: cloudFunction.trigger.allowInsecure ? "SECURE_OPTIONAL" : "SECURE_ALWAYS",
        };
    }
    proto.copyIfPresent(gcfFunction, cloudFunction, "serviceAccountEmail", "timeout", "availableMemoryMb", "minInstances", "maxInstances", "vpcConnector", "vpcConnectorEgressSettings", "ingressSettings", "labels", "environmentVariables");
    return gcfFunction;
}
exports.toGCFv1Function = toGCFv1Function;
function fromGCFv1Function(gcfFunction) {
    var _a;
    const [, project, , region, , id] = gcfFunction.name.split("/");
    let trigger;
    let uri;
    if (gcfFunction.httpsTrigger) {
        trigger = {
            allowInsecure: gcfFunction.httpsTrigger.securityLevel !== "SECURE_ALWAYS",
        };
        uri = gcfFunction.httpsTrigger.url;
    }
    else {
        trigger = {
            eventType: gcfFunction.eventTrigger.eventType,
            eventFilters: {
                resource: gcfFunction.eventTrigger.resource,
            },
            retry: !!((_a = gcfFunction.eventTrigger.failurePolicy) === null || _a === void 0 ? void 0 : _a.retry),
        };
    }
    if (!isValidRuntime(gcfFunction.runtime)) {
        logger_1.logger.debug("GCFv1 function has a deprecated runtime:", JSON.stringify(gcfFunction, null, 2));
    }
    const cloudFunction = {
        apiVersion: 1,
        id,
        project,
        region,
        trigger,
        entryPoint: gcfFunction.entryPoint,
        runtime: gcfFunction.runtime,
    };
    if (uri) {
        cloudFunction.uri = uri;
    }
    proto.copyIfPresent(cloudFunction, gcfFunction, "serviceAccountEmail", "availableMemoryMb", "timeout", "minInstances", "maxInstances", "vpcConnector", "vpcConnectorEgressSettings", "ingressSettings", "labels", "environmentVariables", "sourceUploadUrl");
    return cloudFunction;
}
exports.fromGCFv1Function = fromGCFv1Function;
function toGCFv2Function(cloudFunction, source) {
    if (cloudFunction.apiVersion != 2) {
        throw new error_1.FirebaseError("Trying to create a v2 CloudFunction with v1 API. This should never happen");
    }
    if (!isValidRuntime(cloudFunction.runtime)) {
        throw new error_1.FirebaseError("Failed internal assertion. Trying to deploy a new function with a deprecated runtime." +
            " This should never happen");
    }
    const gcfFunction = {
        name: functionName(cloudFunction),
        buildConfig: {
            runtime: cloudFunction.runtime,
            entryPoint: cloudFunction.entryPoint,
            source: {
                storageSource: source,
            },
            environmentVariables: {},
        },
        serviceConfig: {},
    };
    proto.copyIfPresent(gcfFunction.serviceConfig, cloudFunction, "availableMemoryMb", "environmentVariables", "vpcConnector", "vpcConnectorEgressSettings", "serviceAccountEmail", "ingressSettings");
    proto.renameIfPresent(gcfFunction.serviceConfig, cloudFunction, "timeoutSeconds", "timeout", proto.secondsFromDuration);
    proto.renameIfPresent(gcfFunction.serviceConfig, cloudFunction, "minInstanceCount", "minInstances");
    proto.renameIfPresent(gcfFunction.serviceConfig, cloudFunction, "maxInstanceCount", "maxInstances");
    if (isEventTrigger(cloudFunction.trigger)) {
        gcfFunction.eventTrigger = {
            eventType: cloudFunction.trigger.eventType,
        };
        if (gcfFunction.eventTrigger.eventType === gcfV2.PUBSUB_PUBLISH_EVENT) {
            gcfFunction.eventTrigger.pubsubTopic = cloudFunction.trigger.eventFilters.resource;
        }
        else {
            gcfFunction.eventTrigger.eventFilters = [];
            for (const [attribute, value] of Object.entries(cloudFunction.trigger.eventFilters)) {
                gcfFunction.eventTrigger.eventFilters.push({ attribute, value });
            }
        }
        if (cloudFunction.trigger.retry) {
            logger_1.logger.warn("Cannot set a retry policy on Cloud Function", cloudFunction.id);
        }
    }
    else if (cloudFunction.trigger.allowInsecure) {
        logger_1.logger.warn("Cannot enable insecure traffic for Cloud Function", cloudFunction.id);
    }
    proto.copyIfPresent(gcfFunction, cloudFunction, "labels");
    return gcfFunction;
}
exports.toGCFv2Function = toGCFv2Function;
function fromGCFv2Function(gcfFunction) {
    const [, project, , region, , id] = gcfFunction.name.split("/");
    let trigger;
    if (gcfFunction.eventTrigger) {
        trigger = {
            eventType: gcfFunction.eventTrigger.eventType,
            eventFilters: {},
            retry: false,
        };
        if (gcfFunction.eventTrigger.pubsubTopic) {
            trigger.eventFilters.resource = gcfFunction.eventTrigger.pubsubTopic;
        }
        else {
            for (const { attribute, value } of gcfFunction.eventTrigger.eventFilters || []) {
                trigger.eventFilters[attribute] = value;
            }
        }
    }
    else {
        trigger = {
            allowInsecure: false,
        };
    }
    if (!isValidRuntime(gcfFunction.buildConfig.runtime)) {
        logger_1.logger.debug("GCFv2 function has a deprecated runtime:", JSON.stringify(gcfFunction, null, 2));
    }
    const cloudFunction = {
        apiVersion: 2,
        id,
        project,
        region,
        trigger,
        entryPoint: gcfFunction.buildConfig.entryPoint,
        runtime: gcfFunction.buildConfig.runtime,
        uri: gcfFunction.serviceConfig.uri,
    };
    proto.copyIfPresent(cloudFunction, gcfFunction.serviceConfig, "serviceAccountEmail", "availableMemoryMb", "vpcConnector", "vpcConnectorEgressSettings", "ingressSettings", "environmentVariables");
    proto.renameIfPresent(cloudFunction, gcfFunction.serviceConfig, "timeout", "timeoutSeconds", proto.durationFromSeconds);
    proto.renameIfPresent(cloudFunction, gcfFunction.serviceConfig, "minInstances", "minInstanceCount");
    proto.renameIfPresent(cloudFunction, gcfFunction.serviceConfig, "maxInstances", "maxInstanceCount");
    proto.copyIfPresent(cloudFunction, gcfFunction, "labels");
    return cloudFunction;
}
exports.fromGCFv2Function = fromGCFv2Function;
function toJob(schedule, appEngineLocation) {
    const job = {
        name: scheduleName(schedule, appEngineLocation),
        schedule: schedule.schedule,
    };
    proto.copyIfPresent(job, schedule, "retryConfig");
    if (schedule.transport === "https") {
        throw new error_1.FirebaseError("HTTPS transport for scheduled functions is not yet supported");
    }
    job.pubsubTarget = {
        topicName: topicName(schedule),
        attributes: {
            scheduled: "true",
        },
    };
    return job;
}
exports.toJob = toJob;
async function existingBackend(context, forceRefresh) {
    const ctx = context;
    if (!ctx.loadedExistingBackend || forceRefresh) {
        await loadExistingBackend(ctx);
    }
    return ctx.existingBackend;
}
exports.existingBackend = existingBackend;
async function loadExistingBackend(ctx) {
    var _a, _b, _c;
    ctx.loadedExistingBackend = true;
    ctx.existingBackend = {
        requiredAPIs: {},
        cloudFunctions: [],
        schedules: [],
        topics: [],
    };
    ctx.unreachableRegions = {
        gcfV1: [],
        gcfV2: [],
    };
    const gcfV1Results = await gcf.listAllFunctions(ctx.projectId);
    for (const apiFunction of gcfV1Results.functions) {
        const specFunction = fromGCFv1Function(apiFunction);
        ctx.existingBackend.cloudFunctions.push(specFunction);
        const isScheduled = ((_a = apiFunction.labels) === null || _a === void 0 ? void 0 : _a["deployment-scheduled"]) === "true";
        if (isScheduled) {
            const id = scheduleIdForFunction(specFunction);
            ctx.existingBackend.schedules.push({
                id,
                project: specFunction.project,
                transport: "pubsub",
                targetService: {
                    id: specFunction.id,
                    region: specFunction.region,
                    project: specFunction.project,
                },
            });
            ctx.existingBackend.topics.push({
                id,
                project: specFunction.project,
                targetService: {
                    id: specFunction.id,
                    region: specFunction.region,
                    project: specFunction.project,
                },
            });
        }
    }
    ctx.unreachableRegions.gcfV1 = gcfV1Results.unreachable;
    if (!previews_1.previews.functionsv2) {
        return;
    }
    const gcfV2Results = await gcfV2.listAllFunctions(ctx.projectId);
    for (const apiFunction of gcfV2Results.functions) {
        const specFunction = fromGCFv2Function(apiFunction);
        ctx.existingBackend.cloudFunctions.push(specFunction);
        const pubsubScheduled = ((_b = apiFunction.labels) === null || _b === void 0 ? void 0 : _b["deployment-scheduled"]) === "true";
        const httpsScheduled = ((_c = apiFunction.labels) === null || _c === void 0 ? void 0 : _c["deployment-scheduled"]) === "https";
        if (pubsubScheduled) {
            const id = scheduleIdForFunction(specFunction);
            ctx.existingBackend.schedules.push({
                id,
                project: specFunction.project,
                transport: "pubsub",
                targetService: {
                    id: specFunction.id,
                    region: specFunction.region,
                    project: specFunction.project,
                },
            });
            ctx.existingBackend.topics.push({
                id,
                project: specFunction.project,
                targetService: {
                    id: specFunction.id,
                    region: specFunction.region,
                    project: specFunction.project,
                },
            });
        }
        if (httpsScheduled) {
            const id = scheduleIdForFunction(specFunction);
            ctx.existingBackend.schedules.push({
                id,
                project: specFunction.project,
                transport: "https",
                targetService: {
                    id: specFunction.id,
                    region: specFunction.region,
                    project: specFunction.project,
                },
            });
        }
    }
    ctx.unreachableRegions.gcfV2 = gcfV2Results.unreachable;
}
async function checkAvailability(context, want) {
    const ctx = context;
    if (!ctx.loadedExistingBackend) {
        await loadExistingBackend(ctx);
    }
    const gcfV1Regions = new Set();
    const gcfV2Regions = new Set();
    for (const fn of want.cloudFunctions) {
        if (fn.apiVersion === 1) {
            gcfV1Regions.add(fn.region);
        }
        else {
            gcfV2Regions.add(fn.region);
        }
    }
    const neededUnreachableV1 = ctx.unreachableRegions.gcfV1.filter((region) => gcfV1Regions.has(region));
    const neededUnreachableV2 = ctx.unreachableRegions.gcfV2.filter((region) => gcfV2Regions.has(region));
    if (neededUnreachableV1.length) {
        throw new error_1.FirebaseError("The following Cloud Functions regions are currently unreachable:\n\t" +
            neededUnreachableV1.join("\n\t") +
            "\nThis deployment contains functions in those regions. Please try again in a few minutes, or exclude these regions from your deployment.");
    }
    if (neededUnreachableV2.length) {
        throw new error_1.FirebaseError("The following Cloud Functions V2 regions are currently unreachable:\n\t" +
            neededUnreachableV2.join("\n\t") +
            "\nThis deployment contains functions in those regions. Please try again in a few minutes, or exclude these regions from your deployment.");
    }
    if (ctx.unreachableRegions.gcfV1.length) {
        utils.logLabeledWarning("functions", "The following Cloud Functions regions are currently unreachable:\n" +
            ctx.unreachableRegions.gcfV1.join("\n") +
            "\nCloud Functions in these regions won't be deleted.");
    }
    if (ctx.unreachableRegions.gcfV2.length) {
        utils.logLabeledWarning("functions", "The following Cloud Functions V2 regions are currently unreachable:\n" +
            ctx.unreachableRegions.gcfV2.join("\n") +
            "\nCloud Functions in these regions won't be deleted.");
    }
}
exports.checkAvailability = checkAvailability;
